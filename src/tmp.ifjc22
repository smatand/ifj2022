.IFJcode22
call $skipOperations

#checktype(var1,var2,operand)
label checktype
createframe
pushframe
defvar LF@_bool
defvar LF@_rel2eq
defvar LF@_rel2ans
defvar LF@_jumprel2
defvar LF@_jumprel3
move LF@_jumprel2 bool@false
move LF@_jumprel3 bool@false
defvar LF@_var1
defvar LF@_var2
defvar LF@_operand
defvar LF@type_var1
defvar LF@type_var2 #pravy operand
pops LF@_operand
pops LF@_var2
pops LF@_var1
type LF@type_var1 LF@_var1
type LF@type_var2 LF@_var2
jumpifeq arit1 LF@_operand string@add
jumpifeq arit1 LF@_operand string@sub
jumpifeq arit1 LF@_operand string@mul
jumpifeq arit2 LF@_operand string@div
jumpifeq concat LF@_operand string@concat
jumpifeq compare LF@_operand string@compare
jumpifeq compare LF@_operand string@ncompare
jumpifeq rel1 LF@_operand string@greater
jumpifeq rel1 LF@_operand string@lesser
jumpifeq rel2 LF@_operand string@greatereq
jumpifeq rel3 LF@_operand string@lessereq
label rel3
move LF@_jumprel3 bool@true
jump rel2
label rel3_cmp
eq LF@_rel2eq LF@_var1 LF@_var2
not LF@_bool LF@_bool
or LF@_rel2ans LF@_bool LF@_rel2eq
jumpifeq true_label LF@_rel2ans bool@true
jump false_label
label rel2
move LF@_jumprel2 bool@true
jumpifeq true_label LF@type_var1 string@nil
jumpifeq true_label LF@type_var2 string@nil
jump rel2_jmp1
label rel2_cmp
jumpifeq rel3_cmp LF@_jumprel3 bool@true
eq LF@_rel2eq LF@_var1 LF@_var2
or LF@_rel2ans LF@_bool LF@_rel2eq
jumpifeq true_label LF@_rel2ans bool@true
jump false_label
label rel1
jumpifeq false_label LF@type_var1 string@nil
jumpifeq false_label LF@type_var2 string@nil
label rel2_jmp1
jumpifeq rel1_firststring LF@type_var1 string@string
jumpifeq rel1_firstint LF@type_var1 string@int
jumpifeq rel1_firstfloat LF@type_var1 string@float
label rel1_firstint
jumpifeq rel1_secondfloat LF@type_var2 string@float
gt LF@_bool LF@_var1 LF@_var2
jumpifeq rel2_cmp LF@_jumprel2 bool@true
 #if it is also >= or <=gt LF@_bool LF@_var1 LF@_var2
move LF@_var1 LF@_bool
move LF@_var2 LF@_bool
jump checkEnd
label rel1_secondfloat
pushs LF@_var1
call floatval
pops LF@_var1
gt LF@_bool LF@_var1 LF@_var2
jumpifeq rel2_cmp LF@_jumprel2 bool@true
 #if it is also >= or <=gt LF@_bool LF@_var1 LF@_var2
move LF@_var1 LF@_bool
move LF@_var2 LF@_bool
jump checkEnd
label rel1_firstfloat
pushs LF@_var2
call floatval
pops LF@_var2
gt LF@_bool LF@_var1 LF@_var2
jumpifeq rel2_cmp LF@_jumprel2 bool@true
 #if it is also >= or <=gt LF@_bool LF@_var1 LF@_var2
move LF@_var1 LF@_bool
move LF@_var2 LF@_bool
jump checkEnd
label rel1_firststring
jumpifneq error_sem7 LF@type_var2 string@string
gt LF@_bool LF@_var2 LF@_var1
jumpifeq rel2_cmp LF@_jumprel2 bool@true
 #if it is also >= or <=gt LF@_bool LF@_var2 LF@_var1
move LF@_var1 LF@_bool
move LF@_var2 LF@_bool
jump checkEnd
label false_label
move LF@_var1 bool@false
move LF@_var2 bool@false
jump checkEnd
label true_label
move LF@_var1 bool@true
move LF@_var2 bool@true
jump checkEnd
label compare
jumpifeq skip_compare1 LF@type_var1 LF@type_var2
jump false_label
label skip_compare1
jumpifneq skip_compare2 LF@_var1 LF@_var2
jump true_label
label skip_compare2
jump false_label
jump checkEnd
label concat
jumpifneq skip_concat1 LF@type_var1 string@nil
move LF@_var1 string@
move LF@type_var1 string@string
label skip_concat1
jumpifneq skip_concat2 LF@type_var2 string@nil
move LF@_var2 string@
move LF@type_var2 string@string
label skip_concat2
jumpifneq error_sem7 LF@type_var1 string@string
jumpifneq error_sem7 LF@type_var2 string@string
jump checkEnd
#arit1 = + *
label arit1
defvar LF@booltest
move LF@booltest bool@true
jumpifeq arit1_firstint LF@type_var1 string@int
jumpifeq arit1_firstfloat LF@type_var1 string@float
jumpifeq arit1_firstnull LF@type_var1 string@nil
jump error_sem7 #wrong type of operand
label arit1_firstint
jumpifeq checkEnd LF@type_var2 string@int
jumpifneq arit1_skip1 LF@type_var2 string@float
pushs LF@_var1
call floatval
pops LF@_var1
jump checkEnd
label arit1_skip1
jumpifneq error_sem7 LF@type_var2 string@nil
move LF@_var2 int@0
jump checkEnd
label arit1_firstfloat
jumpifeq checkEnd LF@type_var2 string@float
jumpifneq arit1_skip4 LF@type_var2 string@int
pushs LF@_var2
call floatval
pops LF@_var2
label arit1_skip4
jump checkEnd
label arit1_firstnull
jumpifneq arit1_skip7 LF@type_var2 string@nil
move LF@_var1 int@0
move LF@_var2 int@0
jump checkEnd
label arit1_skip7
jumpifneq arit1_skip8 LF@type_var2 string@int
move LF@_var1 int@0
label arit1_skip8
jump checkEnd
label arit2
jumpifeq arit2_seconod LF@type_var1 string@float
jumpifneq arit2_skip1 LF@type_var1 string@int
pushs LF@_var1
call floatval
pops LF@_var1
jump arit2_second
label arit2_skip1
jumpifneq error_sem7 LF@type_var1 string@nil
move LF@_var1 float@0x0.0p+0 
jump arit2_second
label arit2_second
jumpifeq checkEnd LF@type_var2 string@float
jumpifneq arit2_skip2 LF@type_var2 string@int
pushs LF@_var2
call floatval
pops LF@_var2
jump checkEnd
label arit2_skip2
jumpifneq error_sem7 LF@type_var2 string@nil
move LF@_var2 float@0x0.0p+0
jump checkEnd
label error_sem7
write string@checkType_error_sem_7
exit int@7
label checkEnd
pushs LF@_var2
pushs LF@_var1
pushs LF@_operand
popframe
return


##############################
##compute(op1,op2,operation)##
##############################
label compute
createframe
pushframe
defvar LF@_returnVal
defvar LF@_op1
defvar LF@_op2
defvar LF@_operation
call checktype
pops LF@_operation
pops LF@_op1
pops LF@_op2
jumpifeq computeAdd LF@_operation string@add
jumpifeq computeMul LF@_operation string@mul
jumpifeq computeSub LF@_operation string@sub
jumpifeq computeDiv LF@_operation string@div
jumpifeq computeConcat LF@_operation string@concat
jumpifeq computeCompare LF@_operation string@compare
jumpifeq computeNCompare LF@_operation string@ncompare
jumpifeq computeGreater LF@_operation string@greater
jumpifeq computeLesser LF@_operation string@lesser
jumpifeq computeGreatereq LF@_operation string@greatereq
jumpifeq computeLessereq LF@_operation string@lessereq
label computeAdd
add LF@_returnVal LF@_op1 LF@_op2
jump computeEnd
label computeMul
mul LF@_returnVal LF@_op1 LF@_op2
jump computeEnd
label computeSub
sub LF@_returnVal LF@_op1 LF@_op2
jump computeEnd
label computeDiv
div LF@_returnVal LF@_op1 LF@_op2
jump computeEnd
label computeConcat
concat LF@_returnVal LF@_op1 LF@_op2
jump computeEnd
label computeCompare
move LF@_returnVal LF@_op1
jump computeEnd
label computeNCompare
jumpifeq ncmp_jmp LF@_op1 bool@true
move LF@_returnVal bool@true
jump computeEnd
label ncmp_jmp
move LF@_returnVal bool@false
jump computeEnd
label computeGreater
move LF@_returnVal LF@_op1
jump computeEnd
label computeLesser
jumpifeq lesser_jmp LF@_op1 bool@true
move LF@_returnVal bool@true
jump computeEnd
label lesser_jmp
move LF@_returnVal bool@false
jump computeEnd
label computeGreatereq
move LF@_returnVal LF@_op1
jump computeEnd
label computeLessereq
move LF@_returnVal LF@_op1
jump computeEnd
label computeEnd
pushs LF@_returnVal
popframe
return

label reads
createframe
pushframe
defvar LF@_retval
read TF@_retval string 
pushs TF@_retval
popframe
return
label readi
createframe
pushframe
defvar LF@_retval
read LF@_retval int
pushs LF@_retval
popframe
return
label readf
createframe
pushframe
defvar LF@_retval
read LF@_retval float
pushs LF@_retval
popframe
return
label floatval
createframe
pushframe
defvar LF@_param # also retval
defvar LF@_type
defvar LF@_condition
pops LF@_param
move LF@_condition bool@false
type LF@_type LF@_param # int, bool, float, string or nil
jumpifeq floatval_end LF@_type string@float # no need to convert
jumpifeq int_to_float LF@_type string@int
jumpifeq bool_to_float LF@_type string@bool
move LF@_param float@0x0.0p+0
jump floatval_end
label bool_to_float
eq LF@_condition LF@_param bool@true
jumpifneq bool_false_to_float LF@_condition bool@true
move LF@_param float@0x1.0p+0
jump floatval_end
label bool_false_to_float
move LF@_param float@0x0.0p+0
jump floatval_end
label int_to_float
int2float LF@_param LF@_param
label floatval_end
pushs LF@_param
popframe
return
label intval
createframe
pushframe
defvar LF@_param # also retval
defvar LF@_type
defvar LF@_condition
pops LF@_param
move LF@_condition bool@false
type LF@_type LF@_param # int, bool, float, string or nil
jumpifeq intval_end LF@_type string@int # no need to convert
jumpifeq float_to_int LF@_type string@float
jumpifeq bool_to_int LF@_type string@bool
move LF@_param int@0
jump intval_end 
label bool_to_int
eq LF@_condition LF@_param bool@true
jumpifneq bool_false_to_int LF@_condition bool@true
move LF@_param int@1
jump intval_end
label bool_false_to_int
move LF@_param int@0
jump intval_end
label float_to_int
float2int LF@_param LF@_param
label intval_end
pushs LF@_param
popframe
return
label strval
createframe
pushframe
defvar LF@_retval
defvar LF@_condition
pops LF@_retval
eq LF@_condition LF@_retval nil@nil
jumpifeq strval_end LF@_condition bool@false
move LF@_retval string@
label strval_end
pushs LF@_retval
popframe
return
label substring
createframe
pushframe
defvar LF@_string
defvar LF@_index_from
defvar LF@_index_to
defvar LF@_retval
move LF@_retval string@
defvar LF@_tmp
defvar LF@_strlen
pops LF@_index_to # $j
pops LF@_index_from # $i
pops LF@_string # $s
# errors
lt LF@_tmp LF@_index_from int@0 # $i < 0
jumpifeq substring_return_null LF@_tmp bool@true
lt LF@_tmp LF@_index_to int@0 # $j < 0
jumpifeq substring_return_null LF@_tmp bool@true
gt LF@_tmp LF@_index_from LF@_index_to # $i > $j
jumpifeq substring_return_null LF@_tmp bool@true
strlen LF@_strlen LF@_string
gt LF@_tmp LF@_index_from LF@_strlen # $i > strlen($s)
jumpifeq substring_return_null LF@_tmp bool@true
jumpifeq substring_return_null LF@_index_from LF@_strlen
gt LF@_tmp LF@_index_to LF@_strlen # $j > strlen($s)
jumpifeq substring_return_null LF@_tmp bool@true
jumpifeq substring_return_null LF@_index_to LF@_index_from
# getchar <var> <symb1> <symb2>
label substring_while
getchar LF@_tmp LF@_string LF@_index_from
concat LF@_retval LF@_retval LF@_tmp
add LF@_index_from LF@_index_from int@1 # $i++
jumpifneq substring_while LF@_index_from LF@_index_to
jump substring_end
label substring_return_null
move LF@_retval nil@nil
label substring_end
pushs LF@_retval
popframe
return
label ord
createframe
pushframe
defvar LF@_string
defvar LF@_retval
pops LF@_string
jumpifeq ord_empty_string LF@_string string@
stri2int LF@_retval LF@_string int@0
jump ord_end
label ord_empty_string
move LF@_retval int@0
label ord_end
pushs LF@_retval
popframe
return
label chr
createframe
pushframe
defvar LF@_int
defvar LF@_retval
pops LF@_int
int2char LF@_retval LF@_int
jump chr_end
label chr_end
pushs LF@_retval
popframe
return
label $skipOperations
createframe
pushframe
defvar LF@$var
move LF@$var int@3

####################
#### Expression ####
####################
createframe
pushframe
defvar LF@tmp1
defvar LF@_tmp1
move LF@_tmp1 string@a
move LF@tmp1 LF@_tmp1 
defvar LF@tmp2
defvar LF@_tmp2
move LF@_tmp2 string@b
move LF@tmp2 LF@_tmp2 
defvar LF@tmp3
pushs LF@tmp1
pushs LF@tmp2
pushs string@concat
call compute
pops LF@tmp3
defvar LF@tmp4
defvar LF@_tmp4
move LF@_tmp4 string@a
move LF@tmp4 LF@_tmp4 
defvar LF@tmp5
defvar LF@_tmp5
move LF@_tmp5 string@a
move LF@tmp5 LF@_tmp5 
defvar LF@tmp6
pushs LF@tmp4
pushs LF@tmp5
pushs string@concat
call compute
pops LF@tmp6
defvar LF@tmp7
pushs LF@tmp3
pushs LF@tmp6
pushs string@greatereq
call compute
pops LF@tmp7
defvar LF@type_tmp7
type LF@type_tmp7 LF@tmp7
jumpifeq exprSkip1 LF@type_tmp7 string@bool
write string@didnt_return_boolean
exit int@7
label exprSkip1
jumpifeq exprTrue LF@tmp7 bool@true
write string@false
jump exprEnd

label exprTrue
write string@true
jump exprEnd

label exprEnd
pushs LF@tmp7
popframe
popframe
