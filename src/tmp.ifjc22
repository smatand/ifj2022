.IFJcode22
call $skipOperations
label floatval
createframe
pushframe
defvar LF@_param # also retval
defvar LF@_type
defvar LF@_condition
pops LF@_param
move LF@_condition bool@false
type LF@_type LF@_param # int, bool, float, string or nil
jumpifeq floatval_end LF@_type string@float # no need to convert
jumpifeq int_to_float LF@_type string@int
jumpifeq bool_to_float LF@_type string@bool
move LF@_param float@0x0.0p+0
jump floatval_end
label bool_to_float
eq LF@_condition LF@_param bool@true
jumpifneq bool_false_to_float LF@_condition bool@true
move LF@_param float@0x1.0p+0
jump floatval_end
label bool_false_to_float
move LF@_param float@0x0.0p+0
jump floatval_end
label int_to_float
int2float LF@_param LF@_param
label floatval_end
pushs LF@_param
popframe
return

#checktype(var1,var2,operand)
label checktype
createframe
pushframe
defvar LF@_var1
defvar LF@_var2
defvar LF@_operand
defvar LF@type_var1
defvar LF@type_var2 #pravy operand
pops LF@_operand
pops LF@_var2
pops LF@_var1
type LF@type_var1 LF@_var1
type LF@type_var2 LF@_var2
jumpifeq arit1 LF@_operand string@add
jumpifeq arit1 LF@_operand string@sub
jumpifeq arit1 LF@_operand string@mul
#arit1 = + * / 
label arit1
jumpifeq arit1_firstint LF@type_var1 string@int
jumpifeq arit1_firstfloat LF@type_var1 string@float
jumpifeq arit1_firstnull LF@type_var1 string@nil
label arit1_firstint
jumpifeq checkEnd LF@type_var2 string@int
jumpifneq arit1_skip1 LF@type_var2 string@float
pushs LF@_var1
call floatval
pops LF@_var1
jump checkEnd
label arit1_skip1
jump checkEnd
label arit1_firstfloat
jumpifeq checkEnd LF@type_var2 string@float
jumpifneq arit1_skip2 LF@type_var2 string@int
pushs LF@_var2
call floatval
pops LF@_var2
label arit1_skip2
jump checkEnd
label arit1_firstnull
 label checkEnd
pushs LF@_var2
pushs LF@_var1
pushs LF@_operand
popframe
return


##############################
##compute(op1,op2,operation)##
##############################
label compute
createframe
pushframe
defvar LF@_returnVal
defvar LF@_op1
defvar LF@_op2
defvar LF@_operation
call checktype
pops LF@_operation
pops LF@_op1
pops LF@_op2
jumpifeq computeAdd LF@_operation string@add
jumpifeq computeMul LF@_operation string@mul
label computeAdd
ADD LF@_returnVal LF@_op1 LF@_op2
jump computeEnd
label computeMul
MUL LF@_returnVal LF@_op1 LF@_op2
jump computeEnd
label computeEnd
pushs LF@_returnVal
popframe
return

label $skipOperations
createframe
pushframe
defvar LF@$var
move LF@$var int@3

####################
#### Expression ####
####################
createframe
pushframe
defvar LF@tmp1
defvar LF@_tmp1
popframe
pushs LF@$var
pushframe
pops LF@_tmp1 
move LF@tmp1 LF@_tmp1 
defvar LF@tmp2
move LF@tmp2 int@1
defvar LF@tmp3
pushs LF@tmp1
pushs LF@tmp2
pushs string@add
call compute
pops LF@tmp3
write LF@tmp3
popframe
